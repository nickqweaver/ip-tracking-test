"use strict";
/**
 * @license
 * Copyright Neekware Inc. All Rights Reserved.
 *
 * Use of this source code is governed by a proprietary notice
 * that can be found at http://neekware.com/license/PRI.html
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIpFromRequest = exports.getHeadersAttribute = exports.getIPsFromString = exports.cleanUpIP = exports.isValidIP = exports.isValidIPv6 = exports.isValidIPv4 = void 0;
/**
 * Check the validity of an IPv4 address
 */
function isValidIPv4(ip) {
    const ipv4_pattern = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    return ipv4_pattern.test(ip);
}
exports.isValidIPv4 = isValidIPv4;
/**
 * Check the validity of an IPv6 address
 */
function isValidIPv6(ip) {
    const ipv6_pattern = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/gi;
    return ipv6_pattern.test(ip);
}
exports.isValidIPv6 = isValidIPv6;
/**
 * Check the validity of an IP address
 */
function isValidIP(ip) {
    return isValidIPv4(ip) || isValidIPv6(ip);
}
exports.isValidIP = isValidIP;
/**
 * Given ip address string, it cleans it up
 */
function cleanUpIP(ip) {
    ip = ip.toLowerCase().trim();
    if (ip.startsWith('::ffff:')) {
        return ip.replace('::ffff:', '');
    }
    return ip;
}
exports.cleanUpIP = cleanUpIP;
/**
 * Given a string, it returns a list of one or more valid IP addresses
 * @param str - string to be parsed
 * @param order - client ip order (default is `left-most`)
 */
function getIPsFromString(str, order = 'left-most') {
    const ipList = { ips: [], count: 0 };
    for (const ip of str
        .toLowerCase()
        .split(',')
        .map(cleanUpIP)
        .filter((ip) => ip)) {
        order === 'left-most' ? ipList.ips.push(ip) : ipList.ips.unshift(ip);
    }
    ipList.count = ipList.ips.length;
    return ipList;
}
exports.getIPsFromString = getIPsFromString;
/**
 * Returns HTTP request headers attribute by key
 * @param headers HTTP request headers
 * @param key HTTP request header key
 */
function getHeadersAttribute(headers, attr) {
    for (const key of Object.keys(headers)) {
        if (key === attr) {
            return headers[key];
        }
        const upperCaseAttr = attr.toUpperCase();
        if (key === upperCaseAttr) {
            return headers[key];
        }
        const lowerCaseAttr = attr.toLowerCase();
        if (key === lowerCaseAttr) {
            return headers[key];
        }
        const dashedAttr = attr.replace(/_/g, '-');
        if (key === dashedAttr) {
            return headers[key];
        }
        const dashedCapitalizedSnakeCaseAttr = dashedAttr
            .split('-')
            .map((part) => `${part.charAt(0).toUpperCase()}${part.substr(1).toLowerCase()}`)
            .join('-');
        if (key === dashedCapitalizedSnakeCaseAttr) {
            return headers[key];
        }
        const underscoredAttr = attr.replace(/-/g, '_');
        if (key === underscoredAttr) {
            return headers[key];
        }
        const underscoredCapitalizedSnakeCaseAttr = underscoredAttr
            .split('_')
            .map((part) => `${part.charAt(0).toUpperCase()}${part.substr(1).toLowerCase()}`)
            .join('_');
        if (key === underscoredCapitalizedSnakeCaseAttr) {
            return headers[key];
        }
        const dashedAttrUpperCase = dashedAttr.toUpperCase();
        if (key === dashedAttrUpperCase) {
            return headers[key];
        }
        const underscoredAttrLowerCase = underscoredAttr.toLowerCase();
        if (key === underscoredAttrLowerCase) {
            return headers[key];
        }
    }
    return '';
}
exports.getHeadersAttribute = getHeadersAttribute;
/**
 * Returns ip address information from the request itself
 */
function getIpFromRequest(request) {
    let ip = '127.0.0.1';
    try {
        ip = request.connection.remoteAddress;
    }
    catch (e) {
        try {
            ip = request.socket.remoteAddress;
        }
        catch (e) {
            try {
                ip = request.connection.socket.remoteAddress;
            }
            catch (e) {
                try {
                    ip = request.info.remoteAddress;
                }
                catch (e) {
                    try {
                        ip = request.requestContext.identity.sourceIp; // AWS Lambda
                    }
                    catch (e) {
                        ip = '127.0.0.1';
                    }
                }
            }
        }
    }
    return ip || '127.0.0.1';
}
exports.getIpFromRequest = getIpFromRequest;
//# sourceMappingURL=ipware.util.js.map